//-----------------------------------------------------------------------------------------------
// MathUtilities.cpp
//

//-----------------------------------------------------------------------------------------------
#include "Engine/MathUtilities.hpp"
#include "Engine/Vector2.hpp"
#include <math.h>
#include <stdlib.h>


//-----------------------------------------------------------------------------------------------
// Lookup table for sin() values for 256 evenly distributed angles around the unit circle,
//	where Byte 0 = 0 degrees, Byte 64 = 90 degrees, Byte 128 = 180 degrees, etc.
// 
// Since byte angles are finite/discrete, each byte-angle represents a range of angles (1/256ths
//	of the circle). These values represent the sin() of the angle at the center of each range.
//
const float g_sinValuesForByteAngles[ 256 ] = {
	0.000000000f,	0.024541229f,	0.049067674f,	0.073564564f,	0.098017140f,	0.122410675f,	0.146730474f,	0.170961889f,	
	0.195090322f,	0.219101240f,	0.242980180f,	0.266712757f,	0.290284677f,	0.313681740f,	0.336889853f,	0.359895037f,	
	0.382683432f,	0.405241314f,	0.427555093f,	0.449611330f,	0.471396737f,	0.492898192f,	0.514102744f,	0.534997620f,	
	0.555570233f,	0.575808191f,	0.595699304f,	0.615231591f,	0.634393284f,	0.653172843f,	0.671558955f,	0.689540545f,	
	0.707106781f,	0.724247083f,	0.740951125f,	0.757208847f,	0.773010453f,	0.788346428f,	0.803207531f,	0.817584813f,	
	0.831469612f,	0.844853565f,	0.857728610f,	0.870086991f,	0.881921264f,	0.893224301f,	0.903989293f,	0.914209756f,	
	0.923879533f,	0.932992799f,	0.941544065f,	0.949528181f,	0.956940336f,	0.963776066f,	0.970031253f,	0.975702130f,	
	0.980785280f,	0.985277642f,	0.989176510f,	0.992479535f,	0.995184727f,	0.997290457f,	0.998795456f,	0.999698819f,	
	1.000000000f,	0.999698819f,	0.998795456f,	0.997290457f,	0.995184727f,	0.992479535f,	0.989176510f,	0.985277642f,	
	0.980785280f,	0.975702130f,	0.970031253f,	0.963776066f,	0.956940336f,	0.949528181f,	0.941544065f,	0.932992799f,	
	0.923879533f,	0.914209756f,	0.903989293f,	0.893224301f,	0.881921264f,	0.870086991f,	0.857728610f,	0.844853565f,	
	0.831469612f,	0.817584813f,	0.803207531f,	0.788346428f,	0.773010453f,	0.757208847f,	0.740951125f,	0.724247083f,	
	0.707106781f,	0.689540545f,	0.671558955f,	0.653172843f,	0.634393284f,	0.615231591f,	0.595699304f,	0.575808191f,	
	0.555570233f,	0.534997620f,	0.514102744f,	0.492898192f,	0.471396737f,	0.449611330f,	0.427555093f,	0.405241314f,	
	0.382683432f,	0.359895037f,	0.336889853f,	0.313681740f,	0.290284677f,	0.266712757f,	0.242980180f,	0.219101240f,	
	0.195090322f,	0.170961889f,	0.146730474f,	0.122410675f,	0.098017140f,	0.073564564f,	0.049067674f,	0.024541229f,	
	0.000000000f,	-0.024541229f,	-0.049067674f,	-0.073564564f,	-0.098017140f,	-0.122410675f,	-0.146730474f,	-0.170961889f,	
	-0.195090322f,	-0.219101240f,	-0.242980180f,	-0.266712757f,	-0.290284677f,	-0.313681740f,	-0.336889853f,	-0.359895037f,	
	-0.382683432f,	-0.405241314f,	-0.427555093f,	-0.449611330f,	-0.471396737f,	-0.492898192f,	-0.514102744f,	-0.534997620f,	
	-0.555570233f,	-0.575808191f,	-0.595699304f,	-0.615231591f,	-0.634393284f,	-0.653172843f,	-0.671558955f,	-0.689540545f,	
	-0.707106781f,	-0.724247083f,	-0.740951125f,	-0.757208847f,	-0.773010453f,	-0.788346428f,	-0.803207531f,	-0.817584813f,	
	-0.831469612f,	-0.844853565f,	-0.857728610f,	-0.870086991f,	-0.881921264f,	-0.893224301f,	-0.903989293f,	-0.914209756f,	
	-0.923879533f,	-0.932992799f,	-0.941544065f,	-0.949528181f,	-0.956940336f,	-0.963776066f,	-0.970031253f,	-0.975702130f,	
	-0.980785280f,	-0.985277642f,	-0.989176510f,	-0.992479535f,	-0.995184727f,	-0.997290457f,	-0.998795456f,	-0.999698819f,	
	-1.000000000f,	-0.999698819f,	-0.998795456f,	-0.997290457f,	-0.995184727f,	-0.992479535f,	-0.989176510f,	-0.985277642f,	
	-0.980785280f,	-0.975702130f,	-0.970031253f,	-0.963776066f,	-0.956940336f,	-0.949528181f,	-0.941544065f,	-0.932992799f,	
	-0.923879533f,	-0.914209756f,	-0.903989293f,	-0.893224301f,	-0.881921264f,	-0.870086991f,	-0.857728610f,	-0.844853565f,	
	-0.831469612f,	-0.817584813f,	-0.803207531f,	-0.788346428f,	-0.773010453f,	-0.757208847f,	-0.740951125f,	-0.724247083f,	
	-0.707106781f,	-0.689540545f,	-0.671558955f,	-0.653172843f,	-0.634393284f,	-0.615231591f,	-0.595699304f,	-0.575808191f,	
	-0.555570233f,	-0.534997620f,	-0.514102744f,	-0.492898192f,	-0.471396737f,	-0.449611330f,	-0.427555093f,	-0.405241314f,	
	-0.382683432f,	-0.359895037f,	-0.336889853f,	-0.313681740f,	-0.290284677f,	-0.266712757f,	-0.242980180f,	-0.219101240f,	
	-0.195090322f,	-0.170961889f,	-0.146730474f,	-0.122410675f,	-0.098017140f,	-0.073564564f,	-0.049067674f,	-0.024541229f
};


//-----------------------------------------------------------------------------------------------
float Atan2Degrees( const Vector2& displacement )
{
	return ConvertRadiansToDegrees( atan2f( displacement.y, displacement.x ) );
}


//-----------------------------------------------------------------------------------------------
float CosDegrees( float degrees )
{
	return cosf( ConvertDegreesToRadians( degrees ) );
}


//-----------------------------------------------------------------------------------------------
double CosDegrees( double degrees )
{
	return cos( ConvertDegreesToRadians( degrees ) );
}


//-----------------------------------------------------------------------------------------------
float SinDegrees( float degrees )
{
	return sinf( ConvertDegreesToRadians( degrees ) );
}


//-----------------------------------------------------------------------------------------------
double SinDegrees( double degrees )
{
	return sin( ConvertDegreesToRadians( degrees ) );
}


//-----------------------------------------------------------------------------------------------
float Atan2Degrees( float y, float x )
{
	return ConvertRadiansToDegrees( atan2f( y, x ) );
}


//-----------------------------------------------------------------------------------------------
double Atan2Degrees( double y, double x )
{
	return ConvertRadiansToDegrees( atan2( y, x ) );
}


//-----------------------------------------------------------------------------------------------
int GetRandomIntInRange( int minValueInclusive, int maxValueInclusive )
{
	// #ToDo: use a faster, better random number generator
	return minValueInclusive + rand() % (1 + maxValueInclusive - minValueInclusive);
}


//-----------------------------------------------------------------------------------------------
int GetRandomIntLessThan( int maxValueNotInclusive )
{
	// #ToDo: use a faster, better random number generator
	return rand() % maxValueNotInclusive;
}


//-----------------------------------------------------------------------------------------------
float GetRandomFloatZeroToOne()
{
	// #ToDo: use a faster, better random number generator
	const float oneOverRandMax = 1.f / static_cast<float>(RAND_MAX);
	return static_cast<float>(rand()) * oneOverRandMax;
}


